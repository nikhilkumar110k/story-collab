// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package db

import (
	"context"

"time")

const addCollaborator = `-- name: AddCollaborator :exec
INSERT INTO story_collaborators(story_id, user_id)
VALUES ($1, $2)
`

type AddCollaboratorParams struct {
	StoryID int64
	UserID  int64
}

func (q *Queries) AddCollaborator(ctx context.Context, arg AddCollaboratorParams) error {
	_, err := q.db.Exec(ctx, addCollaborator, arg.StoryID, arg.UserID)
	return err
}

const createChapter = `-- name: CreateChapter :one
INSERT INTO chapters (story_id, title, content, chapter_number, is_complete, createdat, updatedat)
VALUES ($1, $2, $3, $4, $5, COALESCE($6, now()), COALESCE($7, now()))
RETURNING id, story_id, title, content, chapter_number, is_complete, createdat, updatedat
`

type CreateChapterParams struct {
	StoryID       int64
	Title         string
	Content       string
	ChapterNumber int64
	IsComplete    bool
	Column6       interface{}
	Column7       interface{}
}

func (q *Queries) CreateChapter(ctx context.Context, arg CreateChapterParams) (Chapter, error) {
	row := q.db.QueryRow(ctx, createChapter,
		arg.StoryID,
		arg.Title,
		arg.Content,
		arg.ChapterNumber,
		arg.IsComplete,
		arg.Column6,
		arg.Column7,
	)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.Title,
		&i.Content,
		&i.ChapterNumber,
		&i.IsComplete,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const createStory = `-- name: CreateStory :one
INSERT INTO stories (
  id, title, description, cover_image, user_id, likes, views,
  published_date, last_edited, story_type, status, genres
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7,
  $8, $9, $10, $11, $12
)
RETURNING id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres
`

type CreateStoryParams struct {
	ID            int64
	Title         string
	Description   string
	CoverImage    string
	UserID        int64
	Likes         int64
	Views         int64
	PublishedDate time.Time
	LastEdited    time.Time
	StoryType     string
	Status        StoryStatus
	Genres        []string
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (Story, error) {
	row := q.db.QueryRow(ctx, createStory,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CoverImage,
		arg.UserID,
		arg.Likes,
		arg.Views,
		arg.PublishedDate,
		arg.LastEdited,
		arg.StoryType,
		arg.Status,
		arg.Genres,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.UserID,
		&i.Likes,
		&i.Views,
		&i.PublishedDate,
		&i.LastEdited,
		&i.StoryType,
		&i.Status,
		&i.Genres,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  name, bio, profile_image, location, website,
  followers, following, email, stories_count, is_verified, password
) VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8, $9, $10, $11
) RETURNING id, name, bio, profile_image, location, website, followers, following, email, stories_count, is_verified, password
`

type CreateUserParams struct {
	Name         string
	Bio          string
	ProfileImage string
	Location     string
	Website      string
	Followers    int64
	Following    int64
	Email        string
	StoriesCount int64
	IsVerified   bool
	Password     string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Bio,
		arg.ProfileImage,
		arg.Location,
		arg.Website,
		arg.Followers,
		arg.Following,
		arg.Email,
		arg.StoriesCount,
		arg.IsVerified,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.ProfileImage,
		&i.Location,
		&i.Website,
		&i.Followers,
		&i.Following,
		&i.Email,
		&i.StoriesCount,
		&i.IsVerified,
		&i.Password,
	)
	return i, err
}

const deleteChapter = `-- name: DeleteChapter :one
DELETE FROM chapters
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteChapter(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, deleteChapter, id)
	err := row.Scan(&id)
	return id, err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories WHERE id = $1
`

func (q *Queries) DeleteStory(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteStory, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getChapterByID = `-- name: GetChapterByID :one
SELECT id, story_id, title, content, chapter_number, is_complete, createdat, updatedat
FROM chapters
WHERE id = $1
`

func (q *Queries) GetChapterByID(ctx context.Context, id int64) (Chapter, error) {
	row := q.db.QueryRow(ctx, getChapterByID, id)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.Title,
		&i.Content,
		&i.ChapterNumber,
		&i.IsComplete,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getCollaborator = `-- name: GetCollaborator :one
SELECT story_id, user_id FROM story_collaborators WHERE story_id = $1 AND user_id = $2
`

type GetCollaboratorParams struct {
	StoryID int64
	UserID  int64
}

func (q *Queries) GetCollaborator(ctx context.Context, arg GetCollaboratorParams) (StoryCollaborator, error) {
	row := q.db.QueryRow(ctx, getCollaborator, arg.StoryID, arg.UserID)
	var i StoryCollaborator
	err := row.Scan(&i.StoryID, &i.UserID)
	return i, err
}

const getStoriesByUser = `-- name: GetStoriesByUser :many
SELECT id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres FROM stories WHERE user_id = $1
`

func (q *Queries) GetStoriesByUser(ctx context.Context, userID int64) ([]Story, error) {
	rows, err := q.db.Query(ctx, getStoriesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Story
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.UserID,
			&i.Likes,
			&i.Views,
			&i.PublishedDate,
			&i.LastEdited,
			&i.StoryType,
			&i.Status,
			&i.Genres,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres FROM stories WHERE id = $1
`

func (q *Queries) GetStoryByID(ctx context.Context, id int64) (Story, error) {
	row := q.db.QueryRow(ctx, getStoryByID, id)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.UserID,
		&i.Likes,
		&i.Views,
		&i.PublishedDate,
		&i.LastEdited,
		&i.StoryType,
		&i.Status,
		&i.Genres,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, bio, profile_image, location, website, followers, following, email, stories_count, is_verified, password FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.ProfileImage,
		&i.Location,
		&i.Website,
		&i.Followers,
		&i.Following,
		&i.Email,
		&i.StoriesCount,
		&i.IsVerified,
		&i.Password,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, bio, profile_image, location, website, followers, following, email, stories_count, is_verified, password FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.ProfileImage,
		&i.Location,
		&i.Website,
		&i.Followers,
		&i.Following,
		&i.Email,
		&i.StoriesCount,
		&i.IsVerified,
		&i.Password,
	)
	return i, err
}

const listChaptersByStory = `-- name: ListChaptersByStory :many
SELECT id, story_id, title, content, chapter_number, is_complete, createdat, updatedat
FROM chapters
WHERE story_id = $1
ORDER BY chapter_number
`

func (q *Queries) ListChaptersByStory(ctx context.Context, storyID int64) ([]Chapter, error) {
	rows, err := q.db.Query(ctx, listChaptersByStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chapter
	for rows.Next() {
		var i Chapter
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.Title,
			&i.Content,
			&i.ChapterNumber,
			&i.IsComplete,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollaboratorsByStory = `-- name: ListCollaboratorsByStory :many
SELECT u.id, u.name, u.bio, u.profile_image, u.location, u.website, u.followers, u.following, u.stories_count, u.is_verified, u.email
FROM story_collaborators sc
JOIN users u ON sc.user_id = u.id
WHERE sc.story_id = $1
`

type ListCollaboratorsByStoryRow struct {
	ID           int64
	Name         string
	Bio          string
	ProfileImage string
	Location     string
	Website      string
	Followers    int64
	Following    int64
	StoriesCount int64
	IsVerified   bool
	Email        string
}

func (q *Queries) ListCollaboratorsByStory(ctx context.Context, storyID int64) ([]ListCollaboratorsByStoryRow, error) {
	rows, err := q.db.Query(ctx, listCollaboratorsByStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCollaboratorsByStoryRow
	for rows.Next() {
		var i ListCollaboratorsByStoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.ProfileImage,
			&i.Location,
			&i.Website,
			&i.Followers,
			&i.Following,
			&i.StoriesCount,
			&i.IsVerified,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStories = `-- name: ListStories :many
SELECT id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres FROM stories
`

func (q *Queries) ListStories(ctx context.Context) ([]Story, error) {
	rows, err := q.db.Query(ctx, listStories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Story
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.UserID,
			&i.Likes,
			&i.Views,
			&i.PublishedDate,
			&i.LastEdited,
			&i.StoryType,
			&i.Status,
			&i.Genres,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByUser = `-- name: ListStoriesByUser :many
SELECT id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres FROM stories
WHERE user_id = $1
`

func (q *Queries) ListStoriesByUser(ctx context.Context, userID int64) ([]Story, error) {
	rows, err := q.db.Query(ctx, listStoriesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Story
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.UserID,
			&i.Likes,
			&i.Views,
			&i.PublishedDate,
			&i.LastEdited,
			&i.StoryType,
			&i.Status,
			&i.Genres,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByUserID = `-- name: ListStoriesByUserID :many
SELECT 
  id,
  title,
  description,
  cover_image,
  user_id,
  likes,
  views,
  published_date,
  last_edited,
  story_type,
  status,
  genres
FROM 
  stories
WHERE 
  user_id = $1
ORDER BY 
  published_date DESC NULLS LAST, last_edited DESC
`

func (q *Queries) ListStoriesByUserID(ctx context.Context, userID int64) ([]Story, error) {
	rows, err := q.db.Query(ctx, listStoriesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Story
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.UserID,
			&i.Likes,
			&i.Views,
			&i.PublishedDate,
			&i.LastEdited,
			&i.StoryType,
			&i.Status,
			&i.Genres,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, bio, profile_image, location, website, followers, following, email, stories_count, is_verified, password FROM users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.ProfileImage,
			&i.Location,
			&i.Website,
			&i.Followers,
			&i.Following,
			&i.Email,
			&i.StoriesCount,
			&i.IsVerified,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCollaborator = `-- name: RemoveCollaborator :exec
DELETE FROM story_collaborators WHERE story_id = $1 AND user_id = $2
`

type RemoveCollaboratorParams struct {
	StoryID int64
	UserID  int64
}

func (q *Queries) RemoveCollaborator(ctx context.Context, arg RemoveCollaboratorParams) error {
	_, err := q.db.Exec(ctx, removeCollaborator, arg.StoryID, arg.UserID)
	return err
}

const updateChapter = `-- name: UpdateChapter :one
UPDATE chapters
SET title = COALESCE($2, title),
    content = COALESCE($3, content),
    chapter_number = COALESCE($4, chapter_number),
    is_complete = COALESCE($5, is_complete),
    updatedat = now()
WHERE id = $1
RETURNING id, story_id, title, content, chapter_number, is_complete, createdat, updatedat
`

type UpdateChapterParams struct {
	ID            int64
	Title         string
	Content       string
	ChapterNumber int64
	IsComplete    bool
}

func (q *Queries) UpdateChapter(ctx context.Context, arg UpdateChapterParams) (Chapter, error) {
	row := q.db.QueryRow(ctx, updateChapter,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.ChapterNumber,
		arg.IsComplete,
	)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.Title,
		&i.Content,
		&i.ChapterNumber,
		&i.IsComplete,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const updateStory = `-- name: UpdateStory :one
UPDATE stories SET
  title = $2,
  description = $3,
  cover_image = $4,
  user_id = $5,
  likes = $6,
  views = $7,
  published_date = $8,
  last_edited = $9,
  story_type = $10,
  status = $11,
  genres = $12
WHERE id = $1
RETURNING id, title, description, cover_image, user_id, likes, views, published_date, last_edited, story_type, status, genres
`

type UpdateStoryParams struct {
	ID            int64
	Title         string
	Description   string
	CoverImage    string
	UserID        int64
	Likes         int64
	Views         int64
	PublishedDate time.Time
	LastEdited    time.Time
	StoryType     string
	Status        StoryStatus
	Genres        []string
}

func (q *Queries) UpdateStory(ctx context.Context, arg UpdateStoryParams) (Story, error) {
	row := q.db.QueryRow(ctx, updateStory,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CoverImage,
		arg.UserID,
		arg.Likes,
		arg.Views,
		arg.PublishedDate,
		arg.LastEdited,
		arg.StoryType,
		arg.Status,
		arg.Genres,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CoverImage,
		&i.UserID,
		&i.Likes,
		&i.Views,
		&i.PublishedDate,
		&i.LastEdited,
		&i.StoryType,
		&i.Status,
		&i.Genres,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET name = $2, bio = $3, profile_image = $4, location = $5, website = $6,
followers = $7, following = $8, stories_count = $9, is_verified = $10
WHERE id = $1
RETURNING id, name, bio, profile_image, location, website, followers, following, email, stories_count, is_verified, password
`

type UpdateUserParams struct {
	ID           int64
	Name         string
	Bio          string
	ProfileImage string
	Location     string
	Website      string
	Followers    int64
	Following    int64
	StoriesCount int64
	IsVerified   bool
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Bio,
		arg.ProfileImage,
		arg.Location,
		arg.Website,
		arg.Followers,
		arg.Following,
		arg.StoriesCount,
		arg.IsVerified,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.ProfileImage,
		&i.Location,
		&i.Website,
		&i.Followers,
		&i.Following,
		&i.Email,
		&i.StoriesCount,
		&i.IsVerified,
		&i.Password,
	)
	return i, err
}
